/**
 * Generated by: Raymond Truong
 * Date: 2025/07/22
 */

#pragma once

#include "behavioral_patterns/observer/demo_observer.hpp"
#include "behavioral_patterns/state/demo_state.hpp"
#include "behavioral_patterns/strategy/demo_strategy.hpp"
#include "behavioral_patterns/template_method/demo_template_method.hpp"
#include "behavioral_patterns/visitor_method/demo_visitor_method.hpp"
#include "creational_patterns/abstract_factory/demo_abstract_factory.hpp"
#include "creational_patterns/builder/demo_builder.hpp"
#include "creational_patterns/factory_method/demo_factory_method.hpp"
#include "creational_patterns/prototype/demo_prototype.hpp"
#include "creational_patterns/singleton/demo_singleton.hpp"

using namespace std;
namespace myapp {
    typedef enum {
        singleton,
        builder,
        factory_method,
        abstract_factory,
        prototype,
        observer,
        state,
        strategy,
        template_method,
        visitor_method,
    } demo_type;

    class DemoExample {
    public:
        static void create_demo(const demo_type type) {
            switch (type) {
                case singleton:
                    return demo_singleton();
                case builder:
                    return demo_builder();
                case factory_method:
                    return demo_factory_method();
                case abstract_factory:
                    return demo_abstract_factory();
                case prototype:
                    return demo_prototype();
                case observer:
                    return demo_observer();
                case state:
                    return demo_state();
                case strategy:
                    return demo_strategy();
                case template_method:
                    return demo_template_method();
                case visitor_method:
                    return demo_visitor_method();

                default: cout << "No example!" << endl;
            }
        }

    };
} // namespace myapp
